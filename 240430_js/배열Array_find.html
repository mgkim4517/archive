<body>
  <h1>배열Array_find</h1>
  <script>
    /* 
      prototype 객체
      부모 객체의 속성, 메서드 등을 자식이 상속받아 사용
      재사용을 위해 주로 사용
      부모 객체인 프로토타입을 동적으로 변경할 수 있음

      Object.create(); 새 객체 생성
      const item = Object.create(drinkPrototype);
      drinkPrototype은 item의 프로토타입
      item 객체는 drinkPrototype을 상속받음
    */

    /* 
      Array.prototype.find()
      제공된 배열에서 제공된 테스트 함수를 만족하는 첫 번째 요소를 반환

      배열.find(callbackFn); = 배열.find(콜백함수);
      배열.find( (현재 요소[, 현재 요소 인덱스, 호출된 배열]) => {} );

      반환값: 함수를 만족하는 배열의 첫 번째 요소. 없으면, undefined 반환
    */

    const arr = [10, '20', 20, 30, 40, 54];
    const data = [
      { id: 1, coffee: '아메리카노' },
      { id: 2, coffee: '라떼' },
      { id: 3, coffee: '바닐라라떼' },
      { id: 4, coffee: '카페모카' },
      { id: 4, coffee: '아이스 카페모카' },
      { id: 5, coffee: '아메리카노' },
    ];

    const out1 = arr.find(function (n) {
      return n == 20; // ['20' <- 숫자형 문자열, 20] 
    });
    console.log(typeof out1, out1);

    const out2 = arr.find(num => num === 20);
    console.log(typeof out2, out2); // number 20

    const out3 = arr.find(num => num === 5);
    console.log(typeof out3, out3); // 5가 없기 때문에 undefined

    const out4 = data.find(function(item) {
      return item.id === 3;
    });
    console.log(typeof out4, out4); // object {id: 3, coffee: '바닐라라떼'}

    const out5 = data.find(item => item.id === 4);
    console.log(typeof out5, out5); // object {id: 4, coffee: '카페모카'} 첫 번째로 찾은 값만 반환

    const out6 = data.find(item => item.coffee === '아메리카노');
    console.log(typeof out6, out6);

    const out7 = data.find(item => item.id !== 1);
    console.log(typeof out7, out7); // object {id: 2, coffee: '라떼'} find는 하나만 반환
  </script>
</body>